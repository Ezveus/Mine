#!/usr/bin/env ruby

load "server/TCPHandler.rb"
load "server/WSHandler.rb"

puts "Launching server"

def exitServer exitType, tcpSupervisor, wsSupervisor
  printf "\r"
  begin
    File.delete "ui/webclient/.port"
  rescue
  end
  Mine::Client.clients.each do |client|
    client.exit exitType
  end
  tcpSupervisor.terminate if exitType == :signalCatch
  wsSupervisor.terminate if exitType == :signalCatch
  begin
    $railsPID = File.new("ui/webclient/tmp/pids/server.pid").read.to_i
  rescue Errno::ENOENT
    $railsPID = -42
  end
  Process.kill "INT", $railsPID if $railsPID > 1
  puts "Terminating server"
  exit 0
end

launchRails = false              # Set to false with options

opts = {
  :host => "0.0.0.0",
  :port => 8080,
  :wshost => "0.0.0.0",
  :wsport => 8081,
  :railshost => "0.0.0.0",
  :railsport => 3000
}

opts[:port] = ARGV[0].to_i if ARGV[0]
opts[:wsport] = opts[:port] + 1

if launchRails
  Process.fork do
    Dir.chdir "ui/webclient"
    File.open("./.port", "w") do |f|
      f.puts "#{opts[:port]}|#{opts[:wsport]}"
    end
    puts "Executing rails server -d -b #{opts[:railshost]} -p #{opts[:railsport]}"
    Process.exec "rails server -d -b #{opts[:railshost]} -p #{opts[:railsport]}"
  end
end

begin

  tcpSupervisor = Mine::TCPHandler.supervise opts[:host], opts[:port]
  wsSupervisor = Mine::WSHandler.supervise opts[:wshost], opts[:wsport]
  
  Signal.trap "INT" do
    exitServer :signalCatch, tcpSupervisor, wsSupervisor
  end

  Signal.trap "TERM" do
    exitServer :signalCatch, tcpSupervisor, wsSupervisor
  end

  sleep
rescue Interrupt
  puts "\rOn operating systems where Signal.trap doesn't work,"
  puts "catch Interrupt works."
  exitServer :exceptionCatch, tcpSupervisor, wsSupervisor
end
